webpackJsonp([12],{781:function(e,n,t){var r=t(15),a=t(45),o=t(292).PageRenderer;o.__esModule&&(o=o.default);var i=a({displayName:"WrappedPageRenderer",getInitialState:function(){return{content:t(796)}},componentWillMount:function(){},render:function(){return r.createElement(o,Object.assign({},this.props,{content:this.state.content}))}});i.__catalog_loader__=!0,e.exports=i},796:function(e,n){e.exports="The entry point for RocketJump is called `rj`.\r\n\r\nThe `rj` function takes any number of parameters, each of which is a configuration object or another `RocketJump Partial`, and returns a `RocketJump Partial`. This allows for recursive composition (see [composition](/api/composition)). To stop composing and get a real rocketjump, you have to invoke the last `RocketJump Partial`.\r\n\r\n```code\r\nlang: js\r\n---\r\nimport { rj } from 'redux-rocketjump';\r\nrj({ /* put yout configuration here */ })\r\n```\r\n\r\n# Configuration options\r\n## proxyAction *(object|function)*\r\nThis property can be used to customize the generated actions by adding more ones.\r\n\r\nThis property can be used in two ways\r\n- if it contains an object, then a new action dispatcher is generated for each of the keys. Each value **must** be a function that takes one argument, that is an object containing the default `load` and `unload` action dispatchers, and returns an action dispatcher. \r\n- it it contains a function, that function is invoked with an object containing the default `load` and `unload` action dispatchers as argument, and **must** return an object containing, for each key, an action dispatching function\r\n\r\nExamples: implement complex behaviours\r\n\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    proxyActions: {\r\n        loadMore: ({ load }) => (params = {}, meta = {}) => load(params, { ...meta, more: true })\r\n    }\r\n}\r\n```\r\n\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    proxyActions: ({ load }) => {\r\n        return {\r\n            loadMore: (params = {}, meta = {}) => load(params, { ...meta, more: true })\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## proxySelectors *(object|function)*\r\nThis property can be used to customize the generated selectors by adding more ones.\r\n\r\nThis property can be used in two ways\r\n- if it contains an object, then a new selector is generated for each of the keys. Each value **must** be a function that takes one argument, that is an object containing the default `isLoading`,`getData` and `getError` selectors, and returns a selector. \r\n- it it contains a function, that function is invoked with an object containing the default `isLoading`,`getData` and `getError` selectors as argument, and **must** return an object containing, for each key, a selector\r\n\r\nExamples: add a custom property\r\n\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    proxySelectors: {\r\n        getData: ({ getData }) => createSelector(getData, todos =>\r\n            todos === null ? null : todos.map(todo => ({\r\n                ...todo,\r\n                asReadMe: `* [${todo.done ? 'v' : ''}] ${todo.title}`\r\n            }))\r\n        )\r\n    }\r\n}\r\n```\r\n\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    proxySelectors: ({ getData }) => ({\r\n        getData: createSelector(getData, todos =>\r\n            todos === null ? null : todos.map(todo => ({\r\n                ...todo,\r\n                asReadMe: `* [${todo.done ? 'v' : ''}] ${todo.title}`\r\n            }))\r\n        )\r\n    })\r\n}\r\n```\r\n\r\n## proxyReducer *(function)*\r\nThis property can be used to customize the generated reducer.\r\n\r\nIf given, this property is expected to contain a function that is called with the automatically generated reducer and that **must** return the reducer to be used in place of the default one\r\n\r\nExample: translate error messages\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    proxyReducer: oldReducer => (state, action) => {\r\n        switch(action.type) {\r\n            case 'MY_COOL_ACTION_ERROR':\r\n                return {\r\n                    ...state,\r\n                    errors: translateAll(action.errors)\r\n                }\r\n            default:\r\n                return oldReducer(state, action);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## dataReducer *(function)*\r\nIf this property is set, it **must** contain a sub reducer to handle the `${type}_SUCCESS` action on the piece of state related to data. The default implementation is: \r\n\r\n```code\r\nlang: js\r\n---\r\n(prevState, { type, payload }) => payload.data\r\n```\r\n\r\nExample: deserialize date objects\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    dataReducer: (oldData, { type, payload }) => {\r\n        return payload.map(item => ({\r\n            ...item,\r\n            date: new Date(item.date)\r\n        }))\r\n    }\r\n}\r\n```\r\n\r\n## callApi *(effect)*\r\nIf this property is given then its value is used instead of the `call` function from redux-saga to call the api function. As such, this property **must** contain a generator. \r\n\r\nExample: manage authentication tokens\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    callApi: function *(apiFn, ...args) {\r\n        const token = yield select(state => state.auth.accessToken)\r\n        const result = yield call(apiFn, ...args, token)\r\n        return result\r\n    }\r\n}\r\n```\r\n\r\n## apiExtraParams *(generator|generator[])*\r\nIf this property is given, it is expected to be a generator or an array of generators. These are used sequentially to compute additional parameters to be passed to the `api` function in the `params` argument.\r\nThe first generator is invoked with the `params` and `meta` objects as its arguments, and its output is merged into the `params` object itself. Each of following generators is invoked with the `params` object obtained after the last run and the `meta` object, and the output is merged again in the same way of the first run. In order to achieve this, each generator **must** return an object. The `params` object obtained after the last generator has been invoked and its result has been blended is used to run the asynchronous task. \r\n\r\nExample: manage pagination data\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    apiExtraParams: function *(params, meta) {\r\n        if (meta.loadMore) {\r\n            const next = yield select(state.pagination.next)\r\n            return { next }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## needEffect *(generator)*\r\nIf this property is provided, it is expected to be a generator, which is invoked right before the `api` task begins to run: if the generator yields a falsy value, the `api` run is skipped.\r\n\r\nExample: skip some calls to an API because we are caching the value\r\n```code\r\nlang: js\r\n---\r\nrj({\r\n    // ... other config options ...\r\n    proxyActions: {\r\n        load: ({ load }) => \r\n                (params = {}, meta = {}) =>\r\n                  load(params, { ...meta, cache: true }),\r\n    },\r\n    needEffect: function *(meta) {\r\n        if (!meta.cache) {\r\n            return true\r\n        }\r\n        const { getData } = makeSelectors(config.state)\r\n        const data = yield select(getData)\r\n        return data === null\r\n    }\r\n})\r\n```\r\n\r\n## successEffect *(generator|generator[])*\r\nIf this property is provided, it is expected to be a generator or an array of generators. These generators are invoked when the Promise returned by the `api` function resolves, and each of them is called with the data obtained from the promise resolution along with the `meta` object passed in the action dispatcher.\r\n\r\nExample: do something with the result\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    successEffect: function *(data, meta) {\r\n        if (meta.successMessage) {\r\n            yield put(showSuccessMessage(meta.successMessage))\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## failureEffect *(generator|generator[])*\r\nIf this property is provided, it is expected to be a generator or an array of generators. These generators are invoked when the Promise returned by the `api` function rejects, and each of them is called with the data obtained from the promise rejection along with the `meta` object passed in the action dispatcher.\r\n\r\nExample: alert errors\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    failureEffect: function *(error) {\r\n        yield put(showErrorToast(`Sorry our monkeys are trying to do their best, ${error.message}`))\r\n    }\r\n}\r\n```\r\n\r\n## takeEffect *(effect)*\r\nThe effect that describes how the tasks spawned by the main action type are handled. The default value is `takeLatestAndCancel`: it spawns a task every time the `load` function is called, and cancels any previous pending tasks. This is usually the wanted behaviour in case of GET requests. If you need a different behavior can choose one from `redux-rocketjump/effects`, or you can implement a custom one.\r\n\r\n## takeEffectArgs *(any[])*\r\nIf provided, it **must** be an array of additional params to be passed to `takeEffect`. The elements contained in the array are arbitrary. When `takeEffect` is used, these params are spread as arguments.\r\n\r\n## mapLoadingAction *(function)*\r\nIf provided, it **must** be a function that is applied to the action dispatched by a `load` call and that should be used to transform the action before it is dispatched. It **must** return the modified action.\r\n\r\n## mapSuccessAction *(function)*\r\nIf provided, it **must** be a function that is applied to the action dispatched when `api` completes before it is dispatched. It **must** return the modified action.\r\n\r\n## mapFailureAction *(function)*\r\nIf provided, it **must** be a function that is applied to the action dispatched when `api` fails before it is dispatched. It **must** return the modified action.\r\n\r\n## composeReducer *(function[])*\r\nIt is possibile to pass a list of reducer functions to be composed together, along with the default reducer. Composition here means that any action dispatched to the reducer built by rocketjump will be dispatched through the default reducer, and then through all this list of reducers. This allows the combination of reducers handling different action types\r\n\r\nExample: combining more HOR plugins\r\n```code\r\nlang: js\r\n---\r\n{\r\n    // ... other config options ...\r\n    composeReducer: [\r\n        makeUpdateReducer(\r\n            SET_USER_STARRED,\r\n            'data.list',\r\n            undefined,\r\n            ({ payload: { data: { starred } } }, obj) => ({ ...obj, starred }),\r\n        ),\r\n        makeRemoveListReducer(DELETE_USER),\r\n        makeUpdateReducer(UPDATE_USER, 'data.list'),\r\n    ]\r\n}\r\n```"}});
//# sourceMappingURL=12.ea32bb98.chunk.js.map