{"version":3,"sources":["webpack:///static/14.87ebdaa7.chunk.js","webpack:///./catalog/api-composition.md?094e","webpack:///./catalog/api-composition.md"],"names":["webpackJsonp","783","module","exports","__webpack_require__","React","createReactClass","PageRenderer","__esModule","default","WrappedPageRenderer","displayName","getInitialState","content","componentWillMount","render","createElement","Object","assign","this","props","state","__catalog_loader__","798"],"mappings":"AAAAA,cAAc,KAERC,IACA,SAAUC,EAAQC,EAASC,GCFjC,GAAAC,GAAgBD,EAAQ,IACxBE,EAA2BF,EAAQ,IACnCG,EAAuBH,EAAQ,KAASG,YACxCA,GAAAC,aACAD,IAAAE,QAEA,IAAAC,GAAAJ,GACAK,YAAA,sBACAC,gBAAA,WACA,OAAgBC,QAAST,EAAQ,OAEjCU,mBAAA,aAUAC,OAAA,WACA,MAAAV,GAAAW,cAAAT,EAAAU,OAAAC,UAAiEC,KAAAC,OAAeP,QAAAM,KAAAE,MAAAR,aAGhFH,GAAAY,oBAAA,EACApB,EAAAC,QAAAO,GDUMa,IACA,SAAUrB,EAAQC,GEtCxBD,EAAAC,QAAA","file":"static/14.87ebdaa7.chunk.js","sourcesContent":["webpackJsonp([14],{\n\n/***/ 783:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n    var React = __webpack_require__(15);\n    var createReactClass = __webpack_require__(45);\n    var PageRenderer = __webpack_require__(292).PageRenderer;\n    if (PageRenderer.__esModule) {\n      PageRenderer = PageRenderer.default;\n    }\n    var WrappedPageRenderer = createReactClass({\n      displayName: 'WrappedPageRenderer',\n      getInitialState: function() {\n        return {content: __webpack_require__(798)};\n      },\n      componentWillMount: function() {\n        var component = this;\n        if (false) {\n          module.hot.accept(\"!!../node_modules/raw-loader/index.js!./api-composition.md\", function() {\n            component.setState({\n              content: require(\"!!../node_modules/raw-loader/index.js!./api-composition.md\")\n            })\n          })\n        }\n      },\n      render: function() {\n        return React.createElement(PageRenderer, Object.assign({}, this.props, {content: this.state.content}));\n      }\n    });\n    WrappedPageRenderer.__catalog_loader__ = true;\n    module.exports = WrappedPageRenderer;\n  \n\n/***/ }),\n\n/***/ 798:\n/***/ (function(module, exports) {\n\nmodule.exports = \"RocketJumps can be merged!\\r\\n\\r\\nAs stated in the initial part of the API description, the `rj` function can take several arguments, each of which can be a fresh configuration or the output of a previous call. Calling `rj` with several arguments is interpreted as a composition will.\\r\\n\\r\\n```code\\r\\nlang: js\\r\\n---\\r\\nconst rj1 = rj({ /* config 1 */ })\\r\\n\\r\\nconst rj2 = rj({ /* config 2 */ })\\r\\n\\r\\nconst __GENERATED__ = rj(\\r\\n  rj1,\\r\\n  rj2,\\r\\n  {/* last config */ },\\r\\n)()\\r\\n```\\r\\n\\r\\nRocketjump is thought with the composition in mind, hence a rocketjump can be called with one or more partially evaluated rocketjumps or configurations to be composed together. \\r\\n\\r\\n# How does composition work?\\r\\n## Preamble: multiple configuration objects passed in the same call\\r\\nThis is the most simple case of composition, since it is managed via native object merging, like in the following example\\r\\n\\r\\n```code\\r\\nlang: js\\r\\n---\\r\\nconst config1 = { /* ... config ... */ };\\r\\nconst config2 = { /* ... config ... */ };\\r\\n\\r\\n// The following two invocations yield exactly the same result\\r\\nrj(config1, config2);\\r\\nrj({ ...config1, ...config2 });\\r\\n```\\r\\n\\r\\nDue to this behaviour, in the following paragraphs we will only deal with one configuration object.\\r\\n\\r\\n## Generic composition\\r\\nConsider the following example\\r\\n\\r\\n```code\\r\\nlang: js\\r\\n---\\r\\nconst rj0 = rj({ /* config R */ });\\r\\nconst rj1 = rj(rj0, { /* config O */ });\\r\\nconst rj2 = rj({ /* config C */ });\\r\\nconst rj3 = rj(rj1, rj2, { /* config K */ });\\r\\nconst generated = rj3();\\r\\n```\\r\\n\\r\\nThe composition order goes from top to bottom and from left to right. Hence, in our example, we have the following composition order: `config R > config O > config C > config K`.\\r\\n\\r\\nFirst of all, actions, selectors and reducer are generated from `type` and `state` taken from the last configuration object `config K` in our example). Then the composition tree is traversed:\\r\\n- `proxyActions` and `proxySelectors` are evaluated in composition order, and the result is recursively merged: the `proxyAction` attribute of configO can use the actions generated by the property `proxyAction` in configR, and so on. The same holds for selectors.\\r\\n- `proxyReducer` attributes are applied recursively in composition order. In our example the final reducer will be the output of `proxyReducerK(proxyReducerC(proxyReducerO(proxyReducerR(defaultReducer))))`\\r\\n- `dataReducer`, `callApi`, `takeEffect` and `takeEffectArgs` attributes are not merged, and only the latest in the composition tree is applied. Composition order is, as usual, increasing from top to bottom and from left to right. In our example, the order of precedence would be `config K > config C > config O > config R`. Moreover, `dataReducer` is applied before `proxyReducer`.\\r\\n- `apiExtraParams`, `successEffect` and `failureEffect` generators are chained in composition order\\r\\n- `api` must be defined only in the last configuration object, along with `type` and `state`\"\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/14.87ebdaa7.chunk.js","\n    var React = require('react');\n    var createReactClass = require('create-react-class');\n    var PageRenderer = require('catalog').PageRenderer;\n    if (PageRenderer.__esModule) {\n      PageRenderer = PageRenderer.default;\n    }\n    var WrappedPageRenderer = createReactClass({\n      displayName: 'WrappedPageRenderer',\n      getInitialState: function() {\n        return {content: require(\"!!../node_modules/raw-loader/index.js!./api-composition.md\")};\n      },\n      componentWillMount: function() {\n        var component = this;\n        if (module.hot) {\n          module.hot.accept(\"!!../node_modules/raw-loader/index.js!./api-composition.md\", function() {\n            component.setState({\n              content: require(\"!!../node_modules/raw-loader/index.js!./api-composition.md\")\n            })\n          })\n        }\n      },\n      render: function() {\n        return React.createElement(PageRenderer, Object.assign({}, this.props, {content: this.state.content}));\n      }\n    });\n    WrappedPageRenderer.__catalog_loader__ = true;\n    module.exports = WrappedPageRenderer;\n  \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./catalog/api-composition.md\n// module id = 783\n// module chunks = 14","module.exports = \"RocketJumps can be merged!\\r\\n\\r\\nAs stated in the initial part of the API description, the `rj` function can take several arguments, each of which can be a fresh configuration or the output of a previous call. Calling `rj` with several arguments is interpreted as a composition will.\\r\\n\\r\\n```code\\r\\nlang: js\\r\\n---\\r\\nconst rj1 = rj({ /* config 1 */ })\\r\\n\\r\\nconst rj2 = rj({ /* config 2 */ })\\r\\n\\r\\nconst __GENERATED__ = rj(\\r\\n  rj1,\\r\\n  rj2,\\r\\n  {/* last config */ },\\r\\n)()\\r\\n```\\r\\n\\r\\nRocketjump is thought with the composition in mind, hence a rocketjump can be called with one or more partially evaluated rocketjumps or configurations to be composed together. \\r\\n\\r\\n# How does composition work?\\r\\n## Preamble: multiple configuration objects passed in the same call\\r\\nThis is the most simple case of composition, since it is managed via native object merging, like in the following example\\r\\n\\r\\n```code\\r\\nlang: js\\r\\n---\\r\\nconst config1 = { /* ... config ... */ };\\r\\nconst config2 = { /* ... config ... */ };\\r\\n\\r\\n// The following two invocations yield exactly the same result\\r\\nrj(config1, config2);\\r\\nrj({ ...config1, ...config2 });\\r\\n```\\r\\n\\r\\nDue to this behaviour, in the following paragraphs we will only deal with one configuration object.\\r\\n\\r\\n## Generic composition\\r\\nConsider the following example\\r\\n\\r\\n```code\\r\\nlang: js\\r\\n---\\r\\nconst rj0 = rj({ /* config R */ });\\r\\nconst rj1 = rj(rj0, { /* config O */ });\\r\\nconst rj2 = rj({ /* config C */ });\\r\\nconst rj3 = rj(rj1, rj2, { /* config K */ });\\r\\nconst generated = rj3();\\r\\n```\\r\\n\\r\\nThe composition order goes from top to bottom and from left to right. Hence, in our example, we have the following composition order: `config R > config O > config C > config K`.\\r\\n\\r\\nFirst of all, actions, selectors and reducer are generated from `type` and `state` taken from the last configuration object `config K` in our example). Then the composition tree is traversed:\\r\\n- `proxyActions` and `proxySelectors` are evaluated in composition order, and the result is recursively merged: the `proxyAction` attribute of configO can use the actions generated by the property `proxyAction` in configR, and so on. The same holds for selectors.\\r\\n- `proxyReducer` attributes are applied recursively in composition order. In our example the final reducer will be the output of `proxyReducerK(proxyReducerC(proxyReducerO(proxyReducerR(defaultReducer))))`\\r\\n- `dataReducer`, `callApi`, `takeEffect` and `takeEffectArgs` attributes are not merged, and only the latest in the composition tree is applied. Composition order is, as usual, increasing from top to bottom and from left to right. In our example, the order of precedence would be `config K > config C > config O > config R`. Moreover, `dataReducer` is applied before `proxyReducer`.\\r\\n- `apiExtraParams`, `successEffect` and `failureEffect` generators are chained in composition order\\r\\n- `api` must be defined only in the last configuration object, along with `type` and `state`\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/raw-loader!./catalog/api-composition.md\n// module id = 798\n// module chunks = 14"],"sourceRoot":""}